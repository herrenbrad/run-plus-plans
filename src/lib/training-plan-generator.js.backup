/**
 * RunEq Comprehensive Training Plan Generator
 * Intelligently combines all workout libraries to create varied, progressive training plans
 * Addresses major limitations of repetitive training apps like Runna
 */

import { HillWorkoutLibrary } from './hill-workout-library.js';
import { TempoWorkoutLibrary } from './tempo-workout-library.js';
import { IntervalWorkoutLibrary } from './interval-workout-library.js';
import { LongRunWorkoutLibrary } from './long-run-workout-library.js';
import { StandUpBikeWorkoutLibrary } from './standup-bike-workout-library.js';
import { PaceCalculator } from './pace-calculator.js';

export class TrainingPlanGenerator {
    constructor() {
        // Initialize all workout libraries
        this.hillLibrary = new HillWorkoutLibrary();
        this.tempoLibrary = new TempoWorkoutLibrary();
        this.intervalLibrary = new IntervalWorkoutLibrary();
        this.longRunLibrary = new LongRunWorkoutLibrary();
        this.standUpBikeLibrary = new StandUpBikeWorkoutLibrary();
        this.paceCalculator = new PaceCalculator();

        // Training plan templates based on research from established coaches
        this.planTemplates = {
            "5K": {
                weeksRecommended: 8,
                runsPerWeek: [3, 4, 5],
                focusAreas: ["speed", "vo2max", "lactateThreshold"],
                workoutDistribution: {
                    intervals: 30,    // 30% interval work
                    tempo: 25,        // 25% tempo work  
                    hills: 20,        // 20% hill work
                    longRuns: 25      // 25% long runs
                },
                peakWeeklyMileage: [15, 25, 35], // by runs per week
                longRunMax: [8, 10, 12]          // by runs per week
            },
            "10K": {
                weeksRecommended: 10,
                runsPerWeek: [3, 4, 5, 6],
                focusAreas: ["vo2max", "lactateThreshold", "aerobicPower"],
                workoutDistribution: {
                    intervals: 25,
                    tempo: 30,
                    hills: 20, 
                    longRuns: 25
                },
                peakWeeklyMileage: [20, 30, 40, 50],
                longRunMax: [10, 12, 15, 18]
            },
            "Half": {
                weeksRecommended: 12,
                runsPerWeek: [4, 5, 6, 7],
                focusAreas: ["lactateThreshold", "aerobicPower", "endurance"],
                workoutDistribution: {
                    intervals: 20,
                    tempo: 35,
                    hills: 20,
                    longRuns: 25
                },
                peakWeeklyMileage: [25, 35, 45, 55],
                longRunMax: [13, 15, 18, 20]
            },
            "Marathon": {
                weeksRecommended: 16,
                runsPerWeek: [4, 5, 6, 7],
                focusAreas: ["endurance", "lactateThreshold", "aerobicPower"],
                workoutDistribution: {
                    intervals: 15,
                    tempo: 30,
                    hills: 20,
                    longRuns: 35
                },
                peakWeeklyMileage: [35, 45, 60, 70],
                longRunMax: [20, 22, 24, 26]
            }
        };

        // Periodization phases
        this.trainingPhases = {
            base: {
                name: "Base Building",
                focus: "Aerobic development, easy miles",
                workoutIntensity: "low",
                longRunEmphasis: "easy",
                hillFocus: "long_strength"
            },
            build: {
                name: "Build Phase", 
                focus: "Lactate threshold, tempo work",
                workoutIntensity: "moderate",
                longRunEmphasis: "progressive",
                hillFocus: "medium_vo2"
            },
            peak: {
                name: "Peak/Sharpening",
                focus: "Race-specific speed and power",
                workoutIntensity: "high",
                longRunEmphasis: "raceSimulation", 
                hillFocus: "short_power"
            },
            taper: {
                name: "Taper",
                focus: "Maintain fitness, reduce volume",
                workoutIntensity: "moderate",
                longRunEmphasis: "traditional_easy",
                hillFocus: "short_power"
            }
        };
    }

    /**
     * Generate a complete training plan
     */
    generateTrainingPlan(options = {}) {
        const {
            raceDistance = "10K",
            raceTime = null,
            currentPaces = null,
            runsPerWeek = 4,
            runEqPreference = 0,
            weeksAvailable = null,
            experienceLevel, // beginner, intermediate, advanced - required
            standUpBikeType = null // "cyclete", "elliptigo", or null for running-only
        } = options;

        // Get plan template
        const template = this.planTemplates[raceDistance];
        if (!template) {
            throw new Error(`Race distance ${raceDistance} not supported`);
        }

        // Calculate training paces
        let trainingPaces;
        if (currentPaces) {
            trainingPaces = currentPaces;
        } else if (raceTime) {
            trainingPaces = this.paceCalculator.calculateTrainingPaces(raceDistance, raceTime);
        } else {
            throw new Error("Either currentPaces or raceTime must be provided");
        }

        // Determine plan length
        const planWeeks = weeksAvailable || template.weeksRecommended;
        
        // Calculate weekly structure
        const weeklyStructure = this.calculateWeeklyStructure(
            template,
            runsPerWeek,
            experienceLevel
        );

        // Generate periodization
        const periodization = this.createPeriodization(planWeeks, raceDistance);

        // Generate week-by-week plan
        const weeklyPlans = [];
        for (let week = 1; week <= planWeeks; week++) {
            const weekPlan = this.generateWeekPlan(
                week,
                planWeeks,
                template,
                weeklyStructure,
                periodization,
                trainingPaces,
                runEqPreference,
                experienceLevel,
                standUpBikeType
            );
            weeklyPlans.push(weekPlan);
        }

        return {
            planOverview: {
                raceDistance,
                raceTime,
                runsPerWeek,
                totalWeeks: planWeeks,
                runEqPreference,
                experienceLevel,
                standUpBikeType
            },
            trainingPaces: trainingPaces.runEqPaces || trainingPaces.paces,
            periodization,
            weeklyStructure,
            weeks: weeklyPlans,
            planSummary: this.generatePlanSummary(weeklyPlans, template)
        };
    }

    /**
     * Calculate optimal weekly structure
     */
    calculateWeeklyStructure(template, runsPerWeek, experienceLevel) {
        const runIndex = template.runsPerWeek.indexOf(runsPerWeek);
        if (runIndex === -1) {
            throw new Error(`${runsPerWeek} runs per week not supported for this distance`);
        }

        const structure = {
            runsPerWeek,
            peakMileage: template.peakWeeklyMileage[runIndex],
            longRunMax: template.longRunMax[runIndex],
            workoutDays: this.getWorkoutDays(runsPerWeek),
            easyDays: this.getEasyDays(runsPerWeek),
            restDays: 7 - runsPerWeek
        };

        // Adjust for experience level
        if (experienceLevel === "beginner") {
            structure.peakMileage *= 0.8;
            structure.longRunMax *= 0.9;
        } else if (experienceLevel === "advanced") {
            structure.peakMileage *= 1.15;
            structure.longRunMax *= 1.1;
        }

        return structure;
    }

    getWorkoutDays(runsPerWeek) {
        const workoutSchedules = {
            3: ["Tuesday", "Saturday"], // 2 workouts
            4: ["Tuesday", "Thursday", "Saturday"], // 3 workouts  
            5: ["Tuesday", "Thursday", "Saturday", "Sunday"], // 4 workouts
            6: ["Monday", "Tuesday", "Thursday", "Saturday", "Sunday"], // 5 workouts
            7: ["Monday", "Tuesday", "Wednesday", "Thursday", "Saturday", "Sunday"] // 6 workouts
        };
        return workoutSchedules[runsPerWeek] || [];
    }

    getEasyDays(runsPerWeek) {
        const easySchedules = {
            3: ["Thursday"], // 1 easy day
            4: ["Monday"], // 1 easy day
            5: ["Monday"], // 1 easy day  
            6: ["Friday"], // 1 easy day
            7: ["Friday"] // 1 easy day
        };
        return easySchedules[runsPerWeek] || [];
    }

    /**
     * Create periodization plan
     */
    createPeriodization(totalWeeks, raceDistance) {
        const phases = [];
        
        if (totalWeeks <= 8) {
            // Short plan
            phases.push({ phase: "base", weeks: Math.ceil(totalWeeks * 0.4) });
            phases.push({ phase: "build", weeks: Math.ceil(totalWeeks * 0.4) });
            phases.push({ phase: "peak", weeks: Math.floor(totalWeeks * 0.2) });
        } else if (totalWeeks <= 12) {
            // Medium plan
            phases.push({ phase: "base", weeks: Math.ceil(totalWeeks * 0.4) });
            phases.push({ phase: "build", weeks: Math.ceil(totalWeeks * 0.35) });
            phases.push({ phase: "peak", weeks: Math.ceil(totalWeeks * 0.15) });
            phases.push({ phase: "taper", weeks: Math.floor(totalWeeks * 0.1) });
        } else {
            // Long plan (marathon)
            phases.push({ phase: "base", weeks: Math.ceil(totalWeeks * 0.4) });
            phases.push({ phase: "build", weeks: Math.ceil(totalWeeks * 0.35) });
            phases.push({ phase: "peak", weeks: Math.ceil(totalWeeks * 0.15) });
            phases.push({ phase: "taper", weeks: Math.floor(totalWeeks * 0.1) });
        }

        // Add cumulative week tracking
        let cumulativeWeeks = 0;
        phases.forEach(phase => {
            phase.startWeek = cumulativeWeeks + 1;
            phase.endWeek = cumulativeWeeks + phase.weeks;
            cumulativeWeeks += phase.weeks;
        });

        return phases;
    }

    /**
     * Generate individual week plan
     */
    generateWeekPlan(weekNumber, totalWeeks, template, structure, periodization, paces, runEqPreference, experienceLevel, standUpBikeType) {
        // Determine current phase
        const currentPhase = periodization.find(p => 
            weekNumber >= p.startWeek && weekNumber <= p.endWeek
        );

        // Calculate week progression (1 = first week, 0 = rest week)
        const isRestWeek = weekNumber % 4 === 0 && weekNumber < totalWeeks - 2; // Every 4th week except final weeks
        const progressionFactor = isRestWeek ? 0.7 : Math.min(1.0, weekNumber / (totalWeeks * 0.8));

        // Calculate mileage for this week
        const weeklyMileage = Math.round(
            structure.peakMileage * progressionFactor * (isRestWeek ? 0.75 : 1.0)
        );

        // Generate workouts for each day
        const workouts = this.generateWeekWorkouts(
            structure.runsPerWeek,
            weeklyMileage,
            currentPhase,
            template,
            paces,
            runEqPreference,
            experienceLevel,
            weekNumber,
            totalWeeks,
            standUpBikeType
        );

        return {
            week: weekNumber,
            phase: currentPhase.phase,
            isRestWeek,
            totalMileage: weeklyMileage,
            workouts,
            weekFocus: this.getWeekFocus(currentPhase.phase, template.focusAreas),
            notes: this.generateWeekNotes(currentPhase.phase, isRestWeek, weekNumber, totalWeeks)
        };
    }

    /**
     * Generate workouts for a specific week
     */
    generateWeekWorkouts(runsPerWeek, weeklyMileage, phase, template, paces, runEqPreference, experienceLevel, weekNumber, totalWeeks, standUpBikeType) {
        const workouts = [];
        const workoutDays = this.getWorkoutDays(runsPerWeek);
        const easyDays = this.getEasyDays(runsPerWeek);
        
        // Distribute mileage across runs
        const longRunMiles = this.calculateLongRunDistance(weeklyMileage, runsPerWeek);
        const remainingMiles = weeklyMileage - longRunMiles;
        const otherRunMiles = Math.round(remainingMiles / (runsPerWeek - 1));

        // Generate each day's workout
        workoutDays.forEach((day, index) => {
            if (day === "Sunday" || (day === "Saturday" && runsPerWeek <= 4)) {
                // Long run day
                workouts.push({
                    day,
                    type: "longRun", 
                    workout: this.selectLongRunWorkout(phase, longRunMiles, runEqPreference),
                    distance: longRunMiles,
                    focus: "Endurance"
                });
            } else if (easyDays.includes(day)) {
                // Easy run day
                workouts.push({
                    day,
                    type: "easy",
                    workout: this.generateEasyRun(otherRunMiles, runEqPreference),
                    distance: otherRunMiles,
                    focus: "Recovery"
                });
            } else {
                // Quality workout day - check for stand-up bike specific workouts
                if (standUpBikeType && runEqPreference >= 70) {
                    // Use stand-up bike specific workout
                    const workoutType = this.selectStandUpBikeWorkoutType(index, phase, template);
                    workouts.push({
                        day,
                        type: workoutType,
                        workout: this.selectStandUpBikeWorkout(workoutType, phase, standUpBikeType, otherRunMiles),
                        distance: otherRunMiles,
                        focus: this.getWorkoutFocus(workoutType),
                        equipmentSpecific: true
                    });
                } else {
                    // Use traditional running workouts
                    const workoutType = this.selectWorkoutType(index, phase, template);
                    workouts.push({
                        day,
                        type: workoutType,
                        workout: this.selectQualityWorkout(workoutType, phase, otherRunMiles, runEqPreference, paces),
                        distance: otherRunMiles,
                        focus: this.getWorkoutFocus(workoutType)
                    });
                }
            }
        });

        // Add rest days
        const allDays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
        allDays.forEach(day => {
            if (!workouts.find(w => w.day === day)) {
                workouts.push({
                    day,
                    type: "rest",
                    workout: { name: "Rest Day", description: "Complete rest or light cross-training" },
                    distance: 0,
                    focus: "Recovery"
                });
            }
        });

        return workouts.sort((a, b) => {
            const dayOrder = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
            return dayOrder.indexOf(a.day) - dayOrder.indexOf(b.day);
        });
    }

    /**
     * Intelligently select workout types based on phase and training focus
     */
    selectWorkoutType(workoutIndex, phase, template) {
        const phaseInfo = this.trainingPhases[phase.phase];
        
        // Rotate workout types based on training phase emphasis
        const workoutRotation = {
            base: ["tempo", "hills", "easy"],
            build: ["tempo", "intervals", "hills"],
            peak: ["intervals", "tempo", "hills"], 
            taper: ["tempo", "easy", "intervals"]
        };

        const rotation = workoutRotation[phase.phase];
        return rotation[workoutIndex % rotation.length];
    }

    /**
     * Select specific workout from appropriate library
     */
    selectQualityWorkout(workoutType, phase, targetDistance, runEqPreference, paces) {
        const phaseInfo = this.trainingPhases[phase.phase];
        
        switch (workoutType) {
            case "hills":
                return this.selectHillWorkout(phase, runEqPreference);
            case "tempo":
                return this.selectTempoWorkout(phase, runEqPreference);
            case "intervals":
                return this.selectIntervalWorkout(phase, runEqPreference);
            default:
                return this.generateEasyRun(targetDistance, runEqPreference);
        }
    }

    selectHillWorkout(phase, runEqPreference) {
        const phaseInfo = this.trainingPhases[phase.phase];
        const category = phaseInfo.hillFocus;
        
        const workouts = this.hillLibrary.getWorkoutsByCategory(category);
        if (workouts.length === 0) {
            // Fallback to any hill workout
            const allWorkouts = Object.values(this.hillLibrary.workoutLibrary).flat();
            const randomWorkout = allWorkouts[Math.floor(Math.random() * allWorkouts.length)];
            return this.hillLibrary.prescribeHillWorkout(randomWorkout.name, { runEqPreference });
        }
        
        const selectedWorkout = workouts[Math.floor(Math.random() * workouts.length)];
        return this.hillLibrary.prescribeHillWorkout(selectedWorkout.name, { runEqPreference });
    }

    selectTempoWorkout(phase, runEqPreference) {
        const phaseInfo = this.trainingPhases[phase.phase];
        
        // Select tempo category based on phase
        const categoryMap = {
            base: "TRADITIONAL_TEMPO",
            build: "TEMPO_INTERVALS", 
            peak: "RACE_SPECIFIC",
            taper: "ALTERNATING_TEMPO"
        };

        const category = categoryMap[phase.phase];
        const workouts = this.tempoLibrary.getWorkoutsByCategory(category);
        const selectedWorkout = workouts[Math.floor(Math.random() * workouts.length)];
        return this.tempoLibrary.prescribeTempoWorkout(selectedWorkout.name, { runEqPreference });
    }

    selectIntervalWorkout(phase, runEqPreference) {
        const phaseInfo = this.trainingPhases[phase.phase];
        
        // Select interval category based on phase
        const categoryMap = {
            base: "LONG_INTERVALS",
            build: "VO2_MAX",
            peak: "SHORT_SPEED", 
            taper: "MIXED_INTERVALS"
        };

        const category = categoryMap[phase.phase];
        const workouts = this.intervalLibrary.getWorkoutsByCategory(category);
        const selectedWorkout = workouts[Math.floor(Math.random() * workouts.length)];
        return this.intervalLibrary.prescribeIntervalWorkout(selectedWorkout.name, { runEqPreference });
    }

    selectLongRunWorkout(phase, distance, runEqPreference) {
        const phaseInfo = this.trainingPhases[phase.phase];
        const emphasis = phaseInfo.longRunEmphasis;
        
        // Map emphasis to long run categories
        const categoryMap = {
            easy: "TRADITIONAL_EASY",
            progressive: "PROGRESSIVE_RUNS",
            raceSimulation: "RACE_SIMULATION",
            traditional_easy: "TRADITIONAL_EASY"
        };

        const category = categoryMap[emphasis] || "TRADITIONAL_EASY";
        const workouts = this.longRunLibrary.getWorkoutsByCategory(category);
        const selectedWorkout = workouts[Math.floor(Math.random() * workouts.length)];
        return this.longRunLibrary.prescribeLongRunWorkout(selectedWorkout.name, { runEqPreference, distance });
    }

    generateEasyRun(distance, runEqPreference) {
        const runEqOptions = {
            optionA: "Full easy running",
            optionB: "First half running, second half stand-up bike",
            optionC: "Full stand-up bike (2x time conversion)",
            recommendation: runEqPreference >= 50 ? "Split or full bike workout" : "Full running"
        };

        return {
            name: "Easy Run",
            description: "Conversational pace, aerobic base building",
            structure: `${distance} miles at easy pace`,
            intensity: "easy",
            benefits: "Aerobic development, recovery, base building",
            runEqOptions,
            notes: "Should feel refreshed after this run, not fatigued"
        };
    }

    calculateLongRunDistance(weeklyMileage, runsPerWeek) {
        // Long run should be 25-35% of weekly mileage
        const longRunPercentage = runsPerWeek <= 4 ? 0.35 : 0.30;
        return Math.round(weeklyMileage * longRunPercentage);
    }

    getWorkoutFocus(workoutType) {
        const focusMap = {
            hills: "Power & Strength",
            tempo: "Lactate Threshold",
            intervals: "VO2 Max & Speed",
            easy: "Aerobic Base",
            longRun: "Endurance"
        };
        return focusMap[workoutType] || "General Fitness";
    }

    getWeekFocus(phase, focusAreas) {
        const phaseInfo = this.trainingPhases[phase];
        return `${phaseInfo.name}: ${phaseInfo.focus}`;
    }

    generateWeekNotes(phase, isRestWeek, weekNumber, totalWeeks) {
        const notes = [];
        
        if (isRestWeek) {
            notes.push("RECOVERY WEEK: Reduced volume to allow adaptation and recovery");
        }
        
        const phaseInfo = this.trainingPhases[phase];
        notes.push(`Focus: ${phaseInfo.focus}`);
        
        if (phase === "peak" && weekNumber > totalWeeks - 4) {
            notes.push("Peak phase: Focus on race-specific workouts and maintaining sharpness");
        }
        
        if (phase === "taper") {
            notes.push("Taper phase: Maintain intensity but reduce volume for race readiness");
        }

        return notes;
    }

    generatePlanSummary(weeklyPlans, template) {
        const totalWorkouts = weeklyPlans.reduce((sum, week) => 
            sum + week.workouts.filter(w => w.type !== "rest").length, 0
        );
        
        const workoutTypes = weeklyPlans.reduce((counts, week) => {
            week.workouts.forEach(workout => {
                counts[workout.type] = (counts[workout.type] || 0) + 1;
            });
            return counts;
        }, {});

        const totalMiles = weeklyPlans.reduce((sum, week) => sum + week.totalMileage, 0);

        return {
            totalWorkouts,
            totalMiles,
            workoutBreakdown: workoutTypes,
            averageWeeklyMiles: Math.round(totalMiles / weeklyPlans.length),
            peakWeekMiles: Math.max(...weeklyPlans.map(w => w.totalMileage)),
            varietyScore: Object.keys(workoutTypes).length // More variety = higher score
        };
    }

    /**
     * Select workout type for stand-up bike specific sessions
     */
    selectStandUpBikeWorkoutType(workoutIndex, phase, template) {
        const phaseInfo = this.trainingPhases[phase.phase];
        
        // Stand-up bike rotation emphasizes what the equipment does best
        const workoutRotation = {
            base: ["aerobic_base", "tempo_efforts", "recovery_specific"],
            build: ["tempo_efforts", "high_intensity", "technique_specific"],
            peak: ["high_intensity", "race_specific", "tempo_efforts"], 
            taper: ["technique_specific", "recovery_specific", "race_specific"]
        };

        const rotation = workoutRotation[phase.phase];
        return rotation[workoutIndex % rotation.length];
    }

    /**
     * Select specific stand-up bike workout
     */
    selectStandUpBikeWorkout(workoutType, phase, standUpBikeType, targetDistance) {
        // Map workout types to stand-up bike categories
        const categoryMap = {
            aerobic_base: "AEROBIC_BASE",
            tempo_efforts: "TEMPO_EFFORTS",
            high_intensity: "HIGH_INTENSITY", 
            technique_specific: "TECHNIQUE_SPECIFIC",
            race_specific: "RACE_SPECIFIC",
            recovery_specific: "RECOVERY_SPECIFIC"
        };

        const category = categoryMap[workoutType] || "AEROBIC_BASE";
        const workouts = this.standUpBikeLibrary.workoutLibrary[category];
        
        if (!workouts || workouts.length === 0) {
            // Fallback to any available workout
            const allWorkouts = Object.values(this.standUpBikeLibrary.workoutLibrary).flat();
            const availableWorkouts = allWorkouts.filter(w => 
                w.equipment === standUpBikeType || w.equipment === "both"
            );
            
            if (availableWorkouts.length > 0) {
                const selectedWorkout = availableWorkouts[Math.floor(Math.random() * availableWorkouts.length)];
                return this.standUpBikeLibrary.prescribeStandUpBikeWorkout(selectedWorkout.name, standUpBikeType);
            }
        }

        // Filter workouts available for this equipment
        const availableWorkouts = workouts.filter(w => 
            w.equipment === standUpBikeType || w.equipment === "both"
        );

        if (availableWorkouts.length === 0) {
            // If no equipment-specific workouts, use any "both" workouts
            const bothWorkouts = workouts.filter(w => w.equipment === "both");
            if (bothWorkouts.length > 0) {
                const selectedWorkout = bothWorkouts[Math.floor(Math.random() * bothWorkouts.length)];
                return this.standUpBikeLibrary.prescribeStandUpBikeWorkout(selectedWorkout.name, standUpBikeType);
            }
        }

        const selectedWorkout = availableWorkouts[Math.floor(Math.random() * availableWorkouts.length)];
        return this.standUpBikeLibrary.prescribeStandUpBikeWorkout(selectedWorkout.name, standUpBikeType);
    }
}